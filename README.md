# RSP02Framework

## これはなに？

人工衛星に限らず、組み込みソフトウェアには定型的な処理方法や考え方がある。
たとえば、状態遷移については統一的で汎用的な考え方が知られているが、それをアプリケーション層エンジニアが毎回コーディングするのは、DRY原則違反というだけでなく、FSMの仕組みまで知ったうえでそれを正確にコーディングすることを要求することになり、難易度が跳ね上がる。

この問題を、状態遷移のアルゴリズムは定型処理としてフレームワークが提供し、アプリケーション層エンジニアはこの定型処理を知らなくても実装できる環境構築を目指す。
以下の処理について、定型的な枠組み（フレームワーク）の提供を目的とする。

* コマンド解釈
* 状態遷移
* ログシステム
* 時間取得機構
### コマンド解釈
### 状態遷移
各状態は、IState<T>インターフェースを通じて操作される。各状態は、Enter処理、Execute処理、Exit処理をそれぞれ具象クラスでオーバーライドすることで記述される。これらの処理は、GOFのデザインパターンのひとつであるStrategyパターンで記述され、3つの処理の適切な呼び分け、付随する状態の監理などは、基底classであるStateBase<T>が処理する。
IState<T> -> StateBase<T> -> ConcreteStateの継承関係を持つ。
(Tは、状態IDとしてenum classが渡されることを期待している)

StateMachine classは、これらのConcreteStateを適切に切替ながら実行する。状態の切替のためには、StateIDから対応するConcreteStateを選択するためのStateFactory<T>を利用している。
STLを使用していないため、状態IDからクラスインスタンスの逆引きは線形探索を行っているが、状態数はそれほど大きくならないことが期待できるため、現バージョンでは、この実装を採用している。
将来的には、STLコンテナであるunorderd_map(ハッシュによる連想配列)の採用を検討している。

### ログシステム
ログシステムは、フレームワーク内での定型的なイベント(状態遷移時、Enter,Execute,Exit処理時など)のフレームワーク外への通知に使用しているが、アプリケーション層エンジニアも利用可能な実装となっている。

また、それぞれのエンジニアがそれぞれのログを出力することは、ログの可読性の低下を引き起こし、ログの有用性を毀損するため、原則的にフレームワークのログシステムを使用することを要請する。

### 時間取得機構
組み込み環境では、時間の取得方法がハードウェア環境によって大きく異なる。一般的なRTOSでは、ひとつ以上のtickで時間を管理するが、どの程度まで抽象化されているかは、処理系及びRTOSの仕様に左右される。
本実装では、敢てRSP02 Framework内でTimeProviderを定義し、TimeProviderを差し替えられるようにした。
テスト実装では、clock()をmsec単位に変換して返す簡易実装を提供しているが、実環境ではなんらかのtickをmsec単位で返すようにTimeProviderを差し替えて対応する。
また、簡易的な経過時間計測classとして、TStopWatchを提供している。

## 実装方針

これらのフレームワークを提供するにあたり、ターゲットは比較的非力な部類とされるSTM32L476RGであることと、mbed-osのサポート言語がC++であることから、以下の制限内での実装を行う。

1. mbed-cliが要求する処理系がgcc6であることから、CはC11,C++はC++17(gcc6がサポートする範囲内)に準拠する
1. mbed-osはRTOSをサポートするが、RTOSの学習コストを鑑みてシングルスレッドを前提とする
1. 実行モデル?は、所謂メインループによる一筆書き
1. boostなどの非標準環境は使用しない
1. メモリの断片化による予期しないエラーの可能性を排除するために、素のnew/deleteは使用禁止(placement newについてはこの限りではない)
1. 原則的にSTLの使用は禁止するが、以下の限定的な使用は許容する
	1. boot後の初期化時
 	1. メモリ断片化の怖れのないカスタムアロケータを提供できる場合
 	1. 内部で動的メモリ確保されないことが保証されている場合(c.f. std::functionでキャプチャするオブジェクトサイズが小さいもの)

※現バージョンではSTLは一切使用していない。今後オブジェクトサイズなどを考慮しながら採用していく可能性は残しておく
